@Comment Not all of these may be used

@Comment Category Theory for Programmers (Bartosz Milewski)

@InProceedings{10.1007/978-3-031-25803-9_7,
author="Naus, Nico
and Verbeek, Freek
and Walker, Dale
and Ravindran, Binoy",
editor="Lal, Akash
and Tonetta, Stefano",
title="A Formal Semantics for P-Code",
booktitle="Verified Software. Theories, Tools and Experiments.",
year="2023",
publisher="Springer International Publishing",
address="Cham",
pages="111--128",
abstract="Decompilation is currently a widely used tool in reverse engineering and exploit detection in binaries. Ghidra, developed by the National Security Agency, is one of the most popular decompilers. It decompiles binaries to high P-Code, from which the final decompilation output in C code is generated. Ghidra allows users to work with P-Code, so users can analyze the intermediate representation directly. Several projects make use of this to build tools that perform verification, decompilation, taint analysis and emulation, to name a few. P-Code lacks a formal semantics, and its documentation is limited. It has a notoriously subtle semantics, which makes it hard to do any sort of analysis on P-Code. We show that P-Code, as-is, cannot be given an executable semantics. In this paper, we augment P-Code and define a complete, executable, formal semantics for it. This is done by looking at the documentation and the decompilation results of binaries with known source code. The development of a formal P-Code semantics uncovered several issues in Ghidra, P-Code, and the documentation. We show that these issues affect projects that rely on Ghidra and P-Code. We evaluate the executability of our semantics by building a P-Code interpreter that directly uses our semantics. Our work uncovered several issues in Ghidra and allows Ghidra users to better leverage P-Code.",
isbn="978-3-031-25803-9"
}

@Comment An Introduction to Separation Logic (Draft) (John C Reynolds) (ftp server down?)

@article{10.1145/1455229.1455239,
author = {Yang, Zijiang and Wang, Chao and Gupta, Aarti and Ivan\v{c}i\'{c}, Franjo},
title = {Model Checking Sequential Software Programs via Mixed Symbolic Analysis},
year = {2009},
issue_date = {January 2009},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {14},
number = {1},
issn = {1084-4309},
url = {https://doi.org/10.1145/1455229.1455239},
doi = {10.1145/1455229.1455239},
abstract = {We present an efficient symbolic search algorithm for software model checking. Our algorithms perform word-level reasoning by using a combination of decision procedures in Boolean and integer and real domains, and use novel symbolic search strategies optimized specifically for sequential programs to improve scalability. Experiments on real-world C programs show that the new symbolic search algorithms can achieve several orders-of-magnitude improvements over existing methods based on bit-level (Boolean) reasoning.},
journal = {ACM Trans. Des. Autom. Electron. Syst.},
month = {jan},
articleno = {10},
numpages = {26},
keywords = {Model checking, reachability analysis, image computation, composite symbolic formula, binary decision diagram, presburger arithmetic}
}

@Comment Unclear if this is really critical. Read again more carefully
@inproceedings{10.5555/2486788.2486817,
author = {Le, Wei},
title = {Segmented Symbolic Analysis},
year = {2013},
isbn = {9781467330763},
publisher = {IEEE Press},
abstract = {Symbolic analysis is indispensable for software tools that require program semantic information at compile time. However, determining symbolic values for program variables related to loops and library calls is challenging, as the computation and data related to loops can have statically unknown bounds, and the library sources are typically not available at compile time. In this paper, we propose segmented symbolic analysis, a hybrid technique that enables fully automatic symbolic analysis even for the traditionally challenging code of library calls and loops. The novelties of this work are threefold: 1) we flexibly weave symbolic and concrete executions on the selected parts of the program based on demand; 2) dynamic executions are performed on the unit tests constructed from the code segments to infer program semantics needed by static analysis; and 3) the dynamic information from multiple runs is aggregated via regression analysis. We developed the Helium framework, consisting of a static component that performs symbolic analysis and partitions a program, a dynamic analysis that synthesizes unit tests and automatically infers symbolic values for program variables, and a protocol that enables static and dynamic analyses to be run interactively and concurrently. Our experimental results show that by handling loops and library calls that a traditional symbolic analysis cannot process, segmented symbolic analysis detects 5 times more buffer overflows. The technique is scalable for real-world programs such as putty, tightvnc and snort.},
booktitle = {Proceedings of the 2013 International Conference on Software Engineering},
pages = {212–221},
numpages = {10},
location = {San Francisco, CA, USA},
series = {ICSE '13}
}

@Comment Once again, unclear if we really need this. Read again
@inproceedings{10.1007/978-3-662-49674-9_26,
author = {Luckow, Kasper and Dimja\v{s}evi\'{c}, Marko and Giannakopoulou, Dimitra and Howar, Falk and Isberner, Malte and Kahsai, Temesghen and Rakamari\'{c}, Zvonimir and Raman, Vishwanath},
title = {JDart: A Dynamic Symbolic Analysis Framework},
year = {2016},
isbn = {9783662496732},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
url = {https://doi.org/10.1007/978-3-662-49674-9_26},
doi = {10.1007/978-3-662-49674-9_26},
abstract = {We describe JDart, a dynamic symbolic analysis framework for Java. A distinguishing feature of JDart is its modular architecture: the main component that performs dynamic exploration communicates with a component that efficiently constructs constraints and that interfaces with constraint solvers. These components can easily be extended or modified to support multiple constraint solvers or different exploration strategies. Moreover, JDart has been engineered for robustness, driven by the need to handle complex NASA software. These characteristics, together with its recent open sourcing, make JDart an ideal platform for research and experimentation. In the current release, JDart supports the CORAL, SMTInterpol, and Z3 solvers, and is able to handle NASA software with constraints containing bit operations, floating point arithmetic, and complex arithmetic operations e.g., trigonometric and nonlinear. We illustrate how JDart has been used to support other analysis techniques, such as automated interface generation and testing of libraries. Finally, we demonstrate the versatility and effectiveness of JDart, and compare it with state-of-the-art dynamic or pure symbolic execution engines through an extensive experimental evaluation.},
booktitle = {Proceedings of the 22nd International Conference on Tools and Algorithms for the Construction and Analysis of Systems - Volume 9636},
pages = {442–459},
numpages = {18}
}


@Comment Do I need a seperate citation for the tool of Ghidra?

@Comment Cite the reference specifically, since I DEFINITELY need to cite that.
@Comment https://spinsel.dev/assets/2020-06-17-ghidra-brainfuck-processor-1/ghidra_docs/language_spec/html/pcoderef.html
@Comment The whole thing is terrible though

@Comment Cite the niconaus version of the P-code dumper that mine is based on https://github.com/TCCQ/PCode-Dump is a fork of it

@Comment Cite this other dumper by HackOvert that I used as a reference
@Comment https://github.com/HackOvert/GhidraSnippets#dumping-raw-pcode

@book{Patterson_David_A_;_Hennessy_John_L_1993,
title={Computer Organization and Design: The Hardware/Software Interface},
author={Patterson, David A.; Hennessy, John L.},
publisher={Ap Professional},
year={1993},
date={1993},
edition={Hardcover},
language={English},
pages={1000},
keywords={Computer Systems Analysis & Design, Computer Hardware Design & Architecture, Software Development, Textbooks},
isbn={978-1558602816},
isbn10={155860281X},
url={https://lead.to/amazon/com/?op=bt&la=en&cu=usd&key=155860281X},
url-am={https://www.amazon.com/dp/155860281X/},
url-go={https://books.google.com/books?isbn=9781558602816},
url-wo={https://www.worldcat.org/search?qt=l2a&q=isbn%3A9781558602816},
price={$7.07},
condition={Used(Good)},
timestamp={2023-10-14},
}

@Comment Unclear if I need both this and the above, the above I've looked more into
@book{10.5555/1999263,
author = {Hennessy, John L. and Patterson, David A.},
title = {Computer Architecture, Fifth Edition: A Quantitative Approach},
year = {2011},
isbn = {012383872X},
publisher = {Morgan Kaufmann Publishers Inc.},
address = {San Francisco, CA, USA},
edition = {5th},
abstract = {The computing world today is in the middle of a revolution: mobile clients and cloud computing have emerged as the dominant paradigms driving programming and hardware innovation today. The Fifth Edition of Computer Architecture focuses on this dramatic shift, exploring the ways in which software and technology in the "cloud" are accessed by cell phones, tablets, laptops, and other mobile computing devices. Each chapter includes two real-world examples, one mobile and one datacenter, to illustrate this revolutionary change. Updated to cover the mobile computing revolutionEmphasizes the two most important topics in architecture today: memory hierarchy and parallelism in all its forms.Develops common themes throughout each chapter: power, performance, cost, dependability, protection, programming models, and emerging trends ("What's Next")Includes three review appendices in the printed text. Additional reference appendices are available online.Includes updated Case Studies and completely new exercises.}
}

@Comment Doing almost exactly what we are, but with High P-code and specifically Horn Clauses.
@Comment We want to work with Low, and be slightly more general, but my work is likely going to be extremely overlapping :(
@misc{gennari_2021,
author={Gennari, Jeff},
title={GhiHorn: Path Analysis in Ghidra Using SMT Solvers},
month={Oct},
year={2021},
howpublished={Carnegie Mellon University, Software Engineering Institute's Insights (blog)},
url={https://insights.sei.cmu.edu/blog/ghihorn-path-analysis-in-ghidra-using-smt-solvers/},
note={Accessed: 2023-Oct-13}
}

@Comment cite Crux / more importantly Crucible.


@Comment Two ACM principles of programming langues symposium proceedings
@Comment 1979 6th annual: Systematic Design of Program Analysis Frameworks
@Comment 1977 4th: Abstract Interpretation: A Unifed Lttice Model for Static Analysis of Programs by Construction or Approximation of Fixpoints


@Comment lmao do I need to cite Programming in Haskell (Ghram Hutton) ?
